# Multi-stage production Dockerfile with Google Cloud logging
# Optimized for production deployment with security best practices

# ARG for build-time variables
ARG GO_VERSION=1.25.4
ARG ALPINE_VERSION=3.19
ARG APP_VERSION=v0.0.0-dev

# --- Builder Stage ---
FROM golang:${GO_VERSION}-alpine AS builder

# Install build dependencies including Docker client for multi-arch builds
RUN apk add --no-cache \
    build-base \
    git \
    ca-certificates \
    tzdata

# Set working directory
WORKDIR /src

# Copy go.mod and go.sum first to leverage Docker cache
COPY go.mod go.sum ./
RUN go mod download && go mod verify

# Copy rest of source code
COPY . .

# Generate templ files for dashboard
RUN go run github.com/a-h/templ/cmd/templ@latest generate

# Build application with production optimizations
ARG APP_VERSION
ARG TARGETOS
ARG TARGETARCH

# Build with embedded version and optimized flags
RUN CGO_ENABLED=0 GOOS=${TARGETOS} GOARCH=${TARGETARCH} \
    go build \
    -ldflags="-w -s -X main.version=${APP_VERSION} -X main.buildTime=$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
    -tags=netgo \
    -installsuffix netgo \
    -o /app/obsidian-bot \
    ./cmd/bot/main.go

# --- Production Stage ---
FROM alpine:${ALPINE_VERSION}

# Install runtime dependencies
# Tesseract for OCR, Poppler for PDF handling, Git for vault sync
RUN apk add --no-cache \
    tesseract-ocr \
    tesseract-ocr-data-eng \
    poppler-utils \
    git \
    ca-certificates \
    tzdata \
    curl \
    && rm -rf /var/cache/apk/*

# Create a non-root user with proper groups
RUN addgroup -S -g 1000 appgroup && \
    adduser -S -u 1000 -G appgroup appuser

# Set up application directory with proper permissions
WORKDIR /app

# Copy compiled binary from builder stage
COPY --from=builder /app/obsidian-bot /app/obsidian-bot

# Copy necessary assets and configurations
COPY config.yml /app/config.yml
COPY internal/dashboard/static/ ./internal/dashboard/static

# Create required directories with correct permissions
RUN mkdir -p \
    attachments \
    vault \
    data \
    logs \
    /app/.ssh && \
    chown -R appuser:appgroup /app && \
    chmod 755 /app/obsidian-bot

# Copy health check script
COPY <<'EOF' /app/healthcheck.sh
#!/bin/sh
# Health check for the obsidian-bot
set -e

# Check if the main process is running
if ! pgrep -f "obsidian-bot" > /dev/null; then
    echo "Process not running"
    exit 1
fi

# Check if the HTTP endpoint responds
if ! curl -f http://localhost:8080/api/services/status > /dev/null 2>&1; then
    echo "Health endpoint not responding"
    exit 1
fi

echo "Health check passed"
exit 0
EOF

RUN chmod +x /app/healthcheck.sh && chown appuser:appgroup /app/healthcheck.sh

# Switch to non-root user
USER appuser

# Expose dashboard port
EXPOSE 8080

# Set environment variables for production
ENV ENVIRONMENT=production
ENV PORT=8080
ENV LOG_LEVEL=INFO

# Add healthcheck
HEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \
    CMD /app/healthcheck.sh

# Set entrypoint with proper signal handling
ENTRYPOINT ["/app/obsidian-bot"]

# Labels for metadata
LABEL maintainer="abdoullah.elvogani@example.com" \
      version="${APP_VERSION}" \
      description="Obsidian Bot - Production Ready AI Assistant" \
      org.opencontainers.image.source="https://github.com/Ablay19/obsidian-vault" \
      org.opencontainers.image.licenses="MIT"