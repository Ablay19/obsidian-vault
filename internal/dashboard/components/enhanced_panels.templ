package components

import (
	"context"
)

// RealTimeMonitoringPanel provides advanced real-time monitoring capabilities
templ RealTimeMonitoringPanel(ctx context.Context) {
	<section class="monitoring-panel" aria-labelledby="monitoring-title">
		<header class="panel-header">
			<h2 id="monitoring-title" class="panel-title">
				<span class="material-icons-outlined">monitoring</span>
				Real-Time Monitoring
			</h2>
			<div class="panel-controls">
				<button @click="toggleAutoRefresh()" 
						class="btn btn-secondary"
						:aria-pressed="autoRefresh">
					<span class="material-icons-outlined">refresh</span>
					Auto Refresh
				</button>
				<select @change="changeRefreshRate(this.value)" 
						class="form-select"
						aria-label="Refresh rate">
					<option value="1">1s</option>
					<option value="5" selected>5s</option>
					<option value="10">10s</option>
					<option value="30">30s</option>
				</select>
			</div>
		</header>

		<div class="monitoring-grid" x-data="{
			metrics: {
				cpu: 0,
				memory: 0,
				disk: 0,
				network: 0,
				activeConnections: 0,
				requestsPerSecond: 0,
				errorRate: 0,
				uptime: 0
			},
			chartData: {
				labels: [],
				cpu: [],
				memory: [],
				network: []
			},
			autoRefresh: true,
			refreshInterval: 5000,
			
			init() {
				this.startMonitoring();
				this.setupCharts();
			},
			
			startMonitoring() {
				setInterval(() => {
					if (this.autoRefresh) {
						this.updateMetrics();
					}
				}, this.refreshInterval);
				
				// Initial load
				this.updateMetrics();
			},
			
			async updateMetrics() {
				try {
					const response = await fetch('/api/monitoring/metrics');
					const data = await response.json();
					
					this.metrics = { ...this.metrics, ...data };
					this.updateChartData(data);
				} catch (error) {
					console.error('Failed to update metrics:', error);
				}
			},
			
			updateChartData(data) {
				const now = new Date().toLocaleTimeString();
				
				this.chartData.labels.push(now);
				this.chartData.cpu.push(data.cpu);
				this.chartData.memory.push(data.memory);
				this.chartData.network.push(data.network);
				
				// Keep only last 20 data points
				if (this.chartData.labels.length > 20) {
					this.chartData.labels.shift();
					this.chartData.cpu.shift();
					this.chartData.memory.shift();
					this.chartData.network.shift();
				}
				
				this.updateCharts();
			},
			
			updateCharts() {
				// Update CPU chart
				if (window.cpuChart) {
					window.cpuChart.data.labels = this.chartData.labels;
					window.cpuChart.data.datasets[0].data = this.chartData.cpu;
					window.cpuChart.update('none');
				}
				
				// Update Memory chart
				if (window.memoryChart) {
					window.memoryChart.data.labels = this.chartData.labels;
					window.memoryChart.data.datasets[0].data = this.chartData.memory;
					window.memoryChart.update('none');
				}
				
				// Update Network chart
				if (window.networkChart) {
					window.networkChart.data.labels = this.chartData.labels;
					window.networkChart.data.datasets[0].data = this.chartData.network;
					window.networkChart.update('none');
				}
			},
			
			setupCharts() {
				this.$nextTick(() => {
					// CPU Chart
					const cpuCtx = document.getElementById('cpu-chart');
					if (cpuCtx) {
						window.cpuChart = new Chart(cpuCtx, {
							type: 'line',
							data: {
								labels: this.chartData.labels,
								datasets: [{
									label: 'CPU Usage (%)',
									data: this.chartData.cpu,
									borderColor: '#0066ff',
									backgroundColor: 'rgba(0, 102, 255, 0.1)',
									tension: 0.4
								}]
							},
							options: {
								responsive: true,
								animation: { duration: 0 },
								scales: {
									y: { beginAtZero: true, max: 100 }
								}
							}
						});
					}
					
					// Memory Chart
					const memoryCtx = document.getElementById('memory-chart');
					if (memoryCtx) {
						window.memoryChart = new Chart(memoryCtx, {
							type: 'line',
							data: {
								labels: this.chartData.labels,
								datasets: [{
									label: 'Memory Usage (MB)',
									data: this.chartData.memory,
									borderColor: '#00ff88',
									backgroundColor: 'rgba(0, 255, 136, 0.1)',
									tension: 0.4
								}]
							},
							options: {
								responsive: true,
								animation: { duration: 0 },
								scales: {
									y: { beginAtZero: true }
								}
							}
						});
					}
					
					// Network Chart
					const networkCtx = document.getElementById('network-chart');
					if (networkCtx) {
						window.networkChart = new Chart(networkCtx, {
							type: 'line',
							data: {
								labels: this.chartData.labels,
								datasets: [{
									label: 'Network (KB/s)',
									data: this.chartData.network,
									borderColor: '#00d4ff',
									backgroundColor: 'rgba(0, 212, 255, 0.1)',
									tension: 0.4
								}]
							},
							options: {
								responsive: true,
								animation: { duration: 0 },
								scales: {
									y: { beginAtZero: true }
								}
							}
						});
					}
				});
			},
			
			toggleAutoRefresh() {
				this.autoRefresh = !this.autoRefresh;
				dashboardUtils.showNotification(
					`Auto refresh ${this.autoRefresh ? 'enabled' : 'disabled'}`,
					'info'
				);
			},
			
			changeRefreshRate(rate) {
				this.refreshInterval = parseInt(rate) * 1000;
				dashboardUtils.showNotification(
					`Refresh rate changed to ${rate}s`,
					'info'
				);
			}
		}">
			<!-- System Metrics Overview -->
			<div class="metrics-overview">
				<div class="metric-card">
					<div class="metric-header">
						<span class="material-icons-outlined metric-icon">memory</span>
						<h3>CPU Usage</h3>
					</div>
					<div class="metric-value" x-text="metrics.cpu + '%'"></div>
					<div class="metric-sparkline">
						<canvas id="cpu-chart" width="100" height="30"></canvas>
					</div>
				</div>

				<div class="metric-card">
					<div class="metric-header">
						<span class="material-icons-outlined metric-icon">storage</span>
						<h3>Memory</h3>
					</div>
					<div class="metric-value" x-text="metrics.memory + 'MB'"></div>
					<div class="metric-sparkline">
						<canvas id="memory-chart" width="100" height="30"></canvas>
					</div>
				</div>

				<div class="metric-card">
					<div class="metric-header">
						<span class="material-icons-outlined metric-icon">sd_storage</span>
						<h3>Disk Usage</h3>
					</div>
					<div class="metric-value" x-text="metrics.disk + '%'"></div>
					<div class="progress-bar">
						<div class="progress-fill" 
							 :style="`width: ${metrics.disk}%`"></div>
					</div>
				</div>

				<div class="metric-card">
					<div class="metric-header">
						<span class="material-icons-outlined metric-icon">wifi</span>
						<h3>Network</h3>
					</div>
					<div class="metric-value" x-text="metrics.network + ' KB/s'"></div>
					<div class="metric-sparkline">
						<canvas id="network-chart" width="100" height="30"></canvas>
					</div>
				</div>
			</div>

			<!-- Advanced Metrics -->
			<div class="advanced-metrics">
				<div class="metric-group">
					<h4>Application Metrics</h4>
					<div class="metric-list">
						<div class="metric-item">
							<span class="metric-label">Active Connections</span>
							<span class="metric-number" x-text="metrics.activeConnections"></span>
						</div>
						<div class="metric-item">
							<span class="metric-label">Requests/sec</span>
							<span class="metric-number" x-text="metrics.requestsPerSecond"></span>
						</div>
						<div class="metric-item">
							<span class="metric-label">Error Rate</span>
							<span class="metric-number" 
								  x-text="metrics.errorRate + '%'"
								  :class="metrics.errorRate > 5 ? 'metric-error' : 'metric-success'"></span>
						</div>
						<div class="metric-item">
							<span class="metric-label">Uptime</span>
							<span class="metric-number" x-text="metrics.uptime + ' days'"></span>
						</div>
					</div>
				</div>

				<!-- AI Provider Status -->
				<div class="metric-group">
					<h4>AI Provider Status</h4>
					<div id="ai-providers-status" 
						 hx-get="/api/ai/providers/status"
						 hx-trigger="load, every 5s"
						 hx-target="#ai-providers-status"
						 hx-swap="innerHTML">
						Loading AI provider status...
					</div>
				</div>

				<!-- Recent Activity -->
				<div class="metric-group">
					<h4>Recent Activity</h4>
					<div id="recent-activity"
						 hx-get="/api/activity/recent"
						 hx-trigger="load, every 10s"
						 hx-target="#recent-activity"
						 hx-swap="innerHTML">
						Loading recent activity...
					</div>
				</div>
			</div>
		</div>
	</section>
}

// EnhancedAnalyticsPanel provides comprehensive analytics and insights
templ EnhancedAnalyticsPanel() {
	<section class="analytics-panel" aria-labelledby="analytics-title">
		<header class="panel-header">
			<h2 id="analytics-title" class="panel-title">
				<span class="material-icons-outlined">analytics</span>
				Enhanced Analytics
			</h2>
			<div class="panel-controls">
				<select @change="changeTimeRange(this.value)" 
						class="form-select"
						aria-label="Time range">
					<option value="1h">Last Hour</option>
					<option value="24h" selected>Last 24 Hours</option>
					<option value="7d">Last 7 Days</option>
					<option value="30d">Last 30 Days</option>
				</select>
				<button @click="exportData()" 
						class="btn btn-secondary">
					<span class="material-icons-outlined">download</span>
					Export
				</button>
			</div>
		</header>

		<div class="analytics-content" x-data="{
			timeRange: '24h',
			analytics: {
				totalRequests: 0,
				successRate: 0,
				averageResponseTime: 0,
				topEndpoints: [],
				userActivity: [],
				errorTrends: [],
				providerUsage: {}
			},
			
			init() {
				this.loadAnalytics();
			},
			
			async loadAnalytics() {
				try {
					const response = await fetch(`/api/analytics?range=${this.timeRange}`);
					const data = await response.json();
					this.analytics = data;
					this.updateAnalyticsCharts();
				} catch (error) {
					console.error('Failed to load analytics:', error);
					dashboardUtils.showNotification('Failed to load analytics data', 'error');
				}
			},
			
			updateAnalyticsCharts() {
				this.$nextTick(() => {
					// Update requests chart
					this.updateRequestsChart();
					
					// Update response time chart
					this.updateResponseTimeChart();
					
					// Update provider usage chart
					this.updateProviderChart();
				});
			},
			
			updateRequestsChart() {
				const ctx = document.getElementById('requests-chart');
				if (!ctx) return;
				
				new Chart(ctx, {
					type: 'bar',
					data: {
						labels: this.analytics.topEndpoints.map(e => e.endpoint),
						datasets: [{
							label: 'Requests',
							data: this.analytics.topEndpoints.map(e => e.count),
							backgroundColor: '#0066ff'
						}]
					},
					options: {
						responsive: true,
						scales: {
							y: { beginAtZero: true }
						}
					}
				});
			},
			
			updateResponseTimeChart() {
				const ctx = document.getElementById('response-time-chart');
				if (!ctx) return;
				
				new Chart(ctx, {
					type: 'line',
					data: {
						labels: this.analytics.errorTrends.map(e => e.timestamp),
						datasets: [{
							label: 'Response Time (ms)',
							data: this.analytics.errorTrends.map(e => e.responseTime),
							borderColor: '#00ff88',
							backgroundColor: 'rgba(0, 255, 136, 0.1)',
							tension: 0.4
						}]
					},
					options: {
						responsive: true,
						scales: {
							y: { beginAtZero: true }
						}
					}
				});
			},
			
			updateProviderChart() {
				const ctx = document.getElementById('provider-chart');
				if (!ctx) return;
				
				const providers = Object.keys(this.analytics.providerUsage);
				const usage = Object.values(this.analytics.providerUsage);
				
				new Chart(ctx, {
					type: 'doughnut',
					data: {
						labels: providers,
						datasets: [{
							data: usage,
							backgroundColor: ['#0066ff', '#00ff88', '#ff9500', '#ff3366']
						}]
					},
					options: {
						responsive: true,
						plugins: {
							legend: {
								position: 'bottom'
							}
						}
					}
				});
			},
			
			changeTimeRange(range) {
				this.timeRange = range;
				this.loadAnalytics();
				dashboardUtils.showNotification(`Time range changed to ${range}`, 'info');
			},
			
			exportData() {
				const data = {
					timeRange: this.timeRange,
					analytics: this.analytics,
					exportedAt: new Date().toISOString()
				};
				
				const blob = new Blob([JSON.stringify(data, null, 2)], 
					{ type: 'application/json' });
				const url = URL.createObjectURL(blob);
				const a = document.createElement('a');
				a.href = url;
				a.download = `analytics-${this.timeRange}-${Date.now()}.json`;
				a.click();
				URL.revokeObjectURL(url);
				
				dashboardUtils.showNotification('Analytics data exported', 'success');
			}
		}">
			<!-- Key Metrics -->
			<div class="analytics-overview">
				<div class="analytics-card">
					<h3>Total Requests</h3>
					<div class="analytics-number" x-text="analytics.totalRequests.toLocaleString()"></div>
				</div>

				<div class="analytics-card">
					<h3>Success Rate</h3>
					<div class="analytics-number" 
						 x-text="analytics.successRate + '%'"
						 :class="analytics.successRate >= 95 ? 'analytics-success' : 'analytics-warning'"></div>
				</div>

				<div class="analytics-card">
					<h3>Avg Response Time</h3>
					<div class="analytics-number" 
						 x-text="analytics.averageResponseTime + 'ms'"
						 :class="analytics.averageResponseTime <= 500 ? 'analytics-success' : 'analytics-warning'"></div>
				</div>

				<div class="analytics-card">
					<h3>Active Users</h3>
					<div class="analytics-number" x-text="analytics.userActivity?.length || 0"></div>
				</div>
			</div>

			<!-- Charts -->
			<div class="analytics-charts">
				<div class="chart-container">
					<h4>Top Endpoints</h4>
					<canvas id="requests-chart"></canvas>
				</div>

				<div class="chart-container">
					<h4>Response Time Trends</h4>
					<canvas id="response-time-chart"></canvas>
				</div>

				<div class="chart-container">
					<h4>AI Provider Usage</h4>
					<canvas id="provider-chart"></canvas>
				</div>
			</div>
		</div>
	</section>
}
