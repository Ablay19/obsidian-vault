
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>doppler: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">obsidian-automation/cmd/mauritania-cli/internal/doppler/auth.go (0.0%)</option>
				
				<option value="file1">obsidian-automation/cmd/mauritania-cli/internal/doppler/client.go (43.2%)</option>
				
				<option value="file2">obsidian-automation/cmd/mauritania-cli/internal/doppler/fallback.go (0.0%)</option>
				
				<option value="file3">obsidian-automation/cmd/mauritania-cli/internal/doppler/manager.go (61.4%)</option>
				
				<option value="file4">obsidian-automation/cmd/mauritania-cli/internal/doppler/security.go (0.0%)</option>
				
				<option value="file5">obsidian-automation/cmd/mauritania-cli/internal/doppler/service_tokens.go (0.0%)</option>
				
				<option value="file6">obsidian-automation/cmd/mauritania-cli/tests/e2e/framework.go (75.9%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package doppler

import (
        "context"
        "fmt"
        "os"
        "os/exec"
        "strings"
)

// Authenticator handles Doppler authentication
type Authenticator struct {
        token string
}

// NewAuthenticator creates a new authenticator
func NewAuthenticator() *Authenticator <span class="cov0" title="0">{
        return &amp;Authenticator{}
}</span>

// Login performs Doppler CLI login
func (a *Authenticator) Login(ctx context.Context) error <span class="cov0" title="0">{
        cmd := exec.CommandContext(ctx, "doppler", "login")
        cmd.Stdin = strings.NewReader("") // Non-interactive

        output, err := cmd.CombinedOutput()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("doppler login failed: %w, output: %s", err, string(output))
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// IsAuthenticated checks if user is logged in
func (a *Authenticator) IsAuthenticated(ctx context.Context) bool <span class="cov0" title="0">{
        cmd := exec.CommandContext(ctx, "doppler", "me")
        return cmd.Run() == nil
}</span>

// SetToken sets the authentication token
func (a *Authenticator) SetToken(token string) <span class="cov0" title="0">{
        a.token = token
}</span>

// GetToken retrieves the current token
func (a *Authenticator) GetToken() string <span class="cov0" title="0">{
        if a.token != "" </span><span class="cov0" title="0">{
                return a.token
        }</span>
        <span class="cov0" title="0">return os.Getenv("DOPPLER_TOKEN")</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package doppler

import (
        "context"
        "encoding/json"
        "fmt"
        "os"
        "os/exec"
        "strings"
        "time"
)

// Client represents a Doppler CLI client
type Client struct {
        project string
        config  string
        token   string
        timeout time.Duration
}

// NewClient creates a new Doppler client
func NewClient(project, config string) *Client <span class="cov10" title="4">{
        return &amp;Client{
                project: project,
                config:  config,
                token:   os.Getenv("DOPPLER_TOKEN"),
                timeout: 30 * time.Second,
        }
}</span>

// WithToken sets the service token
func (c *Client) WithToken(token string) *Client <span class="cov0" title="0">{
        c.token = token
        return c
}</span>

// WithTimeout sets the command timeout
func (c *Client) WithTimeout(timeout time.Duration) *Client <span class="cov0" title="0">{
        c.timeout = timeout
        return c
}</span>

// GetSecret retrieves a single secret
func (c *Client) GetSecret(ctx context.Context, key string) (string, error) <span class="cov5" title="2">{
        args := []string{"secrets", "get", key, "--project", c.project, "--config", c.config, "--json"}

        if c.token != "" </span><span class="cov0" title="0">{
                args = append([]string{"--token", c.token}, args...)
        }</span>

        <span class="cov5" title="2">cmd := exec.CommandContext(ctx, "doppler", args...)
        cmd.Env = os.Environ()

        output, err := cmd.CombinedOutput()
        if err != nil </span><span class="cov5" title="2">{
                return "", fmt.Errorf("doppler command failed: %w, output: %s", err, string(output))
        }</span>

        <span class="cov0" title="0">var result struct {
                Value string `json:"value"`
        }

        if err := json.Unmarshal(output, &amp;result); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to parse doppler response: %w", err)
        }</span>

        <span class="cov0" title="0">return result.Value, nil</span>
}

// GetSecrets retrieves all secrets for the project/config
func (c *Client) GetSecrets(ctx context.Context) (map[string]string, error) <span class="cov1" title="1">{
        args := []string{"secrets", "download", "--project", c.project, "--config", c.config, "--json"}

        if c.token != "" </span><span class="cov0" title="0">{
                args = append([]string{"--token", c.token}, args...)
        }</span>

        <span class="cov1" title="1">cmd := exec.CommandContext(ctx, "doppler", args...)
        cmd.Env = os.Environ()

        output, err := cmd.CombinedOutput()
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("doppler command failed: %w, output: %s", err, string(output))
        }</span>

        <span class="cov0" title="0">secrets := make(map[string]string)
        if err := json.Unmarshal(output, &amp;secrets); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse doppler response: %w", err)
        }</span>

        <span class="cov0" title="0">return secrets, nil</span>
}

// Run executes a command with Doppler environment variables
func (c *Client) Run(ctx context.Context, command []string) error <span class="cov0" title="0">{
        args := []string{"run", "--project", c.project, "--config", c.config, "--command", strings.Join(command, " ")}

        if c.token != "" </span><span class="cov0" title="0">{
                args = append([]string{"--token", c.token}, args...)
        }</span>

        <span class="cov0" title="0">cmd := exec.CommandContext(ctx, "doppler", args...)
        cmd.Env = os.Environ()
        cmd.Stdout = os.Stdout
        cmd.Stderr = os.Stderr
        cmd.Stdin = os.Stdin

        return cmd.Run()</span>
}

// IsAvailable checks if Doppler CLI is available and authenticated
func (c *Client) IsAvailable(ctx context.Context) error <span class="cov1" title="1">{
        cmd := exec.CommandContext(ctx, "doppler", "me")
        if c.token != "" </span><span class="cov0" title="0">{
                cmd.Env = append(os.Environ(), "DOPPLER_TOKEN="+c.token)
        }</span>

        <span class="cov1" title="1">if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("doppler not available or not authenticated: %w", err)
        }</span>

        <span class="cov1" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package doppler

import (
        "fmt"
        "os"
        "strconv"
)

// FallbackLoader handles loading fallback environment variables
type FallbackLoader struct {
        fallbacks map[string]string
}

// NewFallbackLoader creates a new fallback loader
func NewFallbackLoader() *FallbackLoader <span class="cov0" title="0">{
        return &amp;FallbackLoader{
                fallbacks: make(map[string]string),
        }
}</span>

// AddFallback adds a fallback value for an environment variable
func (fl *FallbackLoader) AddFallback(key, value string) <span class="cov0" title="0">{
        fl.fallbacks[key] = value
}</span>

// LoadFromEnvFile loads fallbacks from a .env file
func (fl *FallbackLoader) LoadFromEnvFile(filepath string) error <span class="cov0" title="0">{
        // In a real implementation, this would parse a .env file
        // For now, use common test fallbacks
        fl.fallbacks = map[string]string{
                "TEST_DATABASE_URL":   "sqlite://:memory:",
                "TEST_REDIS_ADDR":     "localhost:6379",
                "TEST_TIMEOUT":        "30",
                "TELEGRAM_BOT_TOKEN":  "test_bot_token",
                "WHATSAPP_API_KEY":    "test_whatsapp_key",
                "FACEBOOK_APP_ID":     "test_fb_id",
                "FACEBOOK_APP_SECRET": "test_fb_secret",
                "GEMINI_API_KEY":      "test_gemini_key",
                "GROQ_API_KEY":        "test_groq_key",
                "OPENAI_API_KEY":      "test_openai_key",
                "SESSION_SECRET":      "test_session_secret",
                "BACKEND_HOST":        "localhost:8080",
                "DASHBOARD_URL":       "http://localhost:3000",
        }

        return nil
}</span>

// GetFallback retrieves a fallback value
func (fl *FallbackLoader) GetFallback(key string) (string, bool) <span class="cov0" title="0">{
        value, exists := fl.fallbacks[key]
        return value, exists
}</span>

// ApplyFallbacks applies fallback values to environment if not already set
func (fl *FallbackLoader) ApplyFallbacks() error <span class="cov0" title="0">{
        for key, value := range fl.fallbacks </span><span class="cov0" title="0">{
                if os.Getenv(key) == "" </span><span class="cov0" title="0">{
                        if err := os.Setenv(key, value); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to set fallback env var %s: %w", key, err)
                        }</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

// ValidateRequired checks that required environment variables are set
func (fl *FallbackLoader) ValidateRequired(required []string) error <span class="cov0" title="0">{
        var missing []string

        for _, key := range required </span><span class="cov0" title="0">{
                if os.Getenv(key) == "" </span><span class="cov0" title="0">{
                        if _, hasFallback := fl.fallbacks[key]; !hasFallback </span><span class="cov0" title="0">{
                                missing = append(missing, key)
                        }</span>
                }
        }

        <span class="cov0" title="0">if len(missing) &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("missing required environment variables: %v", missing)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetIntFallback retrieves an integer fallback value
func (fl *FallbackLoader) GetIntFallback(key string, defaultValue int) int <span class="cov0" title="0">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                if intVal, err := strconv.Atoi(value); err == nil </span><span class="cov0" title="0">{
                        return intVal
                }</span>
        }

        <span class="cov0" title="0">if strVal, exists := fl.fallbacks[key]; exists </span><span class="cov0" title="0">{
                if intVal, err := strconv.Atoi(strVal); err == nil </span><span class="cov0" title="0">{
                        return intVal
                }</span>
        }

        <span class="cov0" title="0">return defaultValue</span>
}

// GetBoolFallback retrieves a boolean fallback value
func (fl *FallbackLoader) GetBoolFallback(key string, defaultValue bool) bool <span class="cov0" title="0">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                if boolVal, err := strconv.ParseBool(value); err == nil </span><span class="cov0" title="0">{
                        return boolVal
                }</span>
        }

        <span class="cov0" title="0">if strVal, exists := fl.fallbacks[key]; exists </span><span class="cov0" title="0">{
                if boolVal, err := strconv.ParseBool(strVal); err == nil </span><span class="cov0" title="0">{
                        return boolVal
                }</span>
        }

        <span class="cov0" title="0">return defaultValue</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package doppler

import (
        "context"
        "fmt"
        "os"
        "strings"
        "sync"
)

// Manager handles environment variable loading and management
type Manager struct {
        client    *Client
        fallbacks map[string]string
        cache     map[string]string
        cacheMux  sync.RWMutex
}

// NewManager creates a new environment variable manager
func NewManager(project, config string) *Manager <span class="cov3" title="4">{
        return &amp;Manager{
                client:    NewClient(project, config),
                fallbacks: make(map[string]string),
                cache:     make(map[string]string),
        }
}</span>

// WithFallbacks sets fallback values for when Doppler is unavailable
func (m *Manager) WithFallbacks(fallbacks map[string]string) *Manager <span class="cov3" title="3">{
        for k, v := range fallbacks </span><span class="cov3" title="3">{
                m.fallbacks[k] = v
        }</span>
        <span class="cov3" title="3">return m</span>
}

// LoadSecret loads a single secret with caching and fallback
func (m *Manager) LoadSecret(ctx context.Context, key string) (string, error) <span class="cov2" title="2">{
        // Check cache first
        m.cacheMux.RLock()
        if value, exists := m.cache[key]; exists </span><span class="cov0" title="0">{
                m.cacheMux.RUnlock()
                return value, nil
        }</span>
        <span class="cov2" title="2">m.cacheMux.RUnlock()

        // Try Doppler
        if value, err := m.client.GetSecret(ctx, key); err == nil </span><span class="cov0" title="0">{
                m.cacheMux.Lock()
                m.cache[key] = value
                m.cacheMux.Unlock()
                return value, nil
        }</span>

        // Try environment variable
        <span class="cov2" title="2">if value := os.Getenv(key); value != "" </span><span class="cov1" title="1">{
                m.cacheMux.Lock()
                m.cache[key] = value
                m.cacheMux.Unlock()
                return value, nil
        }</span>

        // Try fallback
        <span class="cov1" title="1">if value, exists := m.fallbacks[key]; exists </span><span class="cov1" title="1">{
                m.cacheMux.Lock()
                m.cache[key] = value
                m.cacheMux.Unlock()
                return value, nil
        }</span>

        <span class="cov0" title="0">return "", fmt.Errorf("secret %s not found in Doppler, environment, or fallbacks", key)</span>
}

// LoadAllSecrets loads all secrets for the project/config
func (m *Manager) LoadAllSecrets(ctx context.Context) (map[string]string, error) <span class="cov1" title="1">{
        // Try Doppler first
        if secrets, err := m.client.GetSecrets(ctx); err == nil </span><span class="cov0" title="0">{
                m.cacheMux.Lock()
                for k, v := range secrets </span><span class="cov0" title="0">{
                        m.cache[k] = v
                }</span>
                <span class="cov0" title="0">m.cacheMux.Unlock()
                return secrets, nil</span>
        }

        // Fallback to environment + fallbacks
        <span class="cov1" title="1">secrets := make(map[string]string)

        // Add environment variables
        for _, env := range os.Environ() </span><span class="cov9" title="66">{
                if idx := strings.Index(env, "="); idx &gt; 0 </span><span class="cov9" title="66">{
                        key := env[:idx]
                        value := env[idx+1:]
                        secrets[key] = value
                }</span>
        }

        // Add fallbacks
        <span class="cov1" title="1">for k, v := range m.fallbacks </span><span class="cov1" title="1">{
                if _, exists := secrets[k]; !exists </span><span class="cov1" title="1">{
                        secrets[k] = v
                }</span>
        }

        <span class="cov1" title="1">if len(secrets) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no secrets available from Doppler, environment, or fallbacks")
        }</span>

        <span class="cov1" title="1">m.cacheMux.Lock()
        for k, v := range secrets </span><span class="cov10" title="67">{
                m.cache[k] = v
        }</span>
        <span class="cov1" title="1">m.cacheMux.Unlock()

        return secrets, nil</span>
}

// SetEnvironment applies secrets to the current process environment
func (m *Manager) SetEnvironment(ctx context.Context) error <span class="cov0" title="0">{
        secrets, err := m.LoadAllSecrets(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">for key, value := range secrets </span><span class="cov0" title="0">{
                os.Setenv(key, value)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ClearCache clears the secret cache
func (m *Manager) ClearCache() <span class="cov0" title="0">{
        m.cacheMux.Lock()
        m.cache = make(map[string]string)
        m.cacheMux.Unlock()
}</span>

// IsAvailable checks if Doppler is available
func (m *Manager) IsAvailable(ctx context.Context) bool <span class="cov1" title="1">{
        return m.client.IsAvailable(ctx) == nil
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package doppler

import (
        "fmt"
        "regexp"
        "strings"
)

// SecurityManager handles credential sanitization and security
type SecurityManager struct {
        sensitivePatterns []*regexp.Regexp
}

// NewSecurityManager creates a new security manager
func NewSecurityManager() *SecurityManager <span class="cov0" title="0">{
        return &amp;SecurityManager{
                sensitivePatterns: []*regexp.Regexp{
                        regexp.MustCompile(`(?i)(password|passwd|pwd|secret|key|token|auth)\s*[:=]\s*["']?[^"'\s]+["']?`),
                        regexp.MustCompile(`(?i)(api_key|apikey|access_token)\s*[:=]\s*["']?[^"'\s]+["']?`),
                        regexp.MustCompile(`(?i)bearer\s+[^"'\s]+`),
                        regexp.MustCompile(`(?i)authorization\s*[:=]\s*["']?[^"'\s]+["']?`),
                },
        }
}</span>

// SanitizeString removes sensitive information from a string
func (sm *SecurityManager) SanitizeString(input string) string <span class="cov0" title="0">{
        result := input
        for _, pattern := range sm.sensitivePatterns </span><span class="cov0" title="0">{
                result = pattern.ReplaceAllString(result, "$1: [REDACTED]")
        }</span>
        <span class="cov0" title="0">return result</span>
}

// SanitizeMap removes sensitive information from a map
func (sm *SecurityManager) SanitizeMap(data map[string]interface{}) map[string]interface{} <span class="cov0" title="0">{
        sanitized := make(map[string]interface{})
        for k, v := range data </span><span class="cov0" title="0">{
                if sm.isSensitiveKey(k) </span><span class="cov0" title="0">{
                        sanitized[k] = "[REDACTED]"
                }</span> else<span class="cov0" title="0"> {
                        sanitized[k] = sm.sanitizeValue(v)
                }</span>
        }
        <span class="cov0" title="0">return sanitized</span>
}

// IsSecureValue checks if a value appears to be properly secured
func (sm *SecurityManager) IsSecureValue(key, value string) bool <span class="cov0" title="0">{
        if sm.isSensitiveKey(key) </span><span class="cov0" title="0">{
                // Sensitive values should not be empty or obvious placeholders
                if value == "" || strings.Contains(strings.ToLower(value), "placeholder") ||
                        strings.Contains(strings.ToLower(value), "example") || strings.Contains(value, "test_") </span><span class="cov0" title="0">{
                        return false
                }</span>
                // Should not contain common insecure patterns
                <span class="cov0" title="0">if strings.Contains(value, "123456") || strings.Contains(value, "password") </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov0" title="0">return true</span>
}

// ValidateCredentials performs basic validation on credentials
func (sm *SecurityManager) ValidateCredentials(creds map[string]string) []string <span class="cov0" title="0">{
        var issues []string

        for key, value := range creds </span><span class="cov0" title="0">{
                if !sm.IsSecureValue(key, value) </span><span class="cov0" title="0">{
                        issues = append(issues, fmt.Sprintf("insecure value for %s", key))
                }</span>
        }

        <span class="cov0" title="0">return issues</span>
}

// isSensitiveKey checks if a key contains sensitive information
func (sm *SecurityManager) isSensitiveKey(key string) bool <span class="cov0" title="0">{
        sensitiveKeys := []string{
                "password", "passwd", "pwd", "secret", "key", "token", "auth",
                "api_key", "apikey", "access_token", "bearer", "authorization",
                "client_secret", "private_key", "session_secret",
        }

        keyLower := strings.ToLower(key)
        for _, sensitive := range sensitiveKeys </span><span class="cov0" title="0">{
                if strings.Contains(keyLower, sensitive) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// sanitizeValue recursively sanitizes values
func (sm *SecurityManager) sanitizeValue(v interface{}) interface{} <span class="cov0" title="0">{
        switch val := v.(type) </span>{
        case string:<span class="cov0" title="0">
                return sm.SanitizeString(val)</span>
        case map[string]interface{}:<span class="cov0" title="0">
                return sm.SanitizeMap(val)</span>
        case []interface{}:<span class="cov0" title="0">
                var sanitized []interface{}
                for _, item := range val </span><span class="cov0" title="0">{
                        sanitized = append(sanitized, sm.sanitizeValue(item))
                }</span>
                <span class="cov0" title="0">return sanitized</span>
        default:<span class="cov0" title="0">
                return val</span>
        }
}

// MaskSecrets creates a display-safe version of secrets
func (sm *SecurityManager) MaskSecrets(secrets map[string]string) map[string]string <span class="cov0" title="0">{
        masked := make(map[string]string)
        for k, v := range secrets </span><span class="cov0" title="0">{
                if sm.isSensitiveKey(k) </span><span class="cov0" title="0">{
                        if len(v) &gt; 4 </span><span class="cov0" title="0">{
                                masked[k] = v[:2] + strings.Repeat("*", len(v)-4) + v[len(v)-2:]
                        }</span> else<span class="cov0" title="0"> {
                                masked[k] = strings.Repeat("*", len(v))
                        }</span>
                } else<span class="cov0" title="0"> {
                        masked[k] = v
                }</span>
        }
        <span class="cov0" title="0">return masked</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package doppler

import (
        "context"
        "encoding/json"
        "fmt"
        "os"
        "os/exec"
)

// ServiceTokenManager handles Doppler service tokens
type ServiceTokenManager struct {
        project string
        token   string
}

// NewServiceTokenManager creates a new service token manager
func NewServiceTokenManager(project string) *ServiceTokenManager <span class="cov0" title="0">{
        return &amp;ServiceTokenManager{
                project: project,
                token:   getDopplerToken(),
        }
}</span>

// CreateToken creates a new service token for a config
func (stm *ServiceTokenManager) CreateToken(ctx context.Context, name, config string) (string, error) <span class="cov0" title="0">{
        args := []string{"service-tokens", "create", name,
                "--project", stm.project, "--config", config, "--json"}

        cmd := exec.CommandContext(ctx, "doppler", args...)
        cmd.Env = append(os.Environ(), "DOPPLER_TOKEN="+stm.token)

        output, err := cmd.CombinedOutput()
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to create service token: %w, output: %s", err, string(output))
        }</span>

        <span class="cov0" title="0">var result struct {
                Key string `json:"key"`
        }

        if err := json.Unmarshal(output, &amp;result); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to parse token response: %w", err)
        }</span>

        <span class="cov0" title="0">return result.Key, nil</span>
}

// ListTokens lists all service tokens for the project
func (stm *ServiceTokenManager) ListTokens(ctx context.Context) ([]ServiceTokenInfo, error) <span class="cov0" title="0">{
        args := []string{"service-tokens", "--project", stm.project, "--json"}

        cmd := exec.CommandContext(ctx, "doppler", args...)
        cmd.Env = append(os.Environ(), "DOPPLER_TOKEN="+stm.token)

        output, err := cmd.CombinedOutput()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list service tokens: %w, output: %s", err, string(output))
        }</span>

        <span class="cov0" title="0">var tokens []ServiceTokenInfo
        if err := json.Unmarshal(output, &amp;tokens); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse tokens response: %w", err)
        }</span>

        <span class="cov0" title="0">return tokens, nil</span>
}

// DeleteToken deletes a service token
func (stm *ServiceTokenManager) DeleteToken(ctx context.Context, slug string) error <span class="cov0" title="0">{
        args := []string{"service-tokens", "delete", slug, "--project", stm.project, "--yes"}

        cmd := exec.CommandContext(ctx, "doppler", args...)
        cmd.Env = append(os.Environ(), "DOPPLER_TOKEN="+stm.token)

        output, err := cmd.CombinedOutput()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete service token: %w, output: %s", err, string(output))
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ValidateToken checks if a service token is valid
func (stm *ServiceTokenManager) ValidateToken(ctx context.Context, token string) error <span class="cov0" title="0">{
        // Try to use the token to access secrets
        testClient := NewClient(stm.project, "dev").WithToken(token)
        return testClient.IsAvailable(ctx)
}</span>

// ServiceTokenInfo represents service token information
type ServiceTokenInfo struct {
        Slug       string `json:"slug"`
        Name       string `json:"name"`
        Project    string `json:"project"`
        Config     string `json:"config"`
        CreatedAt  string `json:"created_at"`
        LastSeenAt string `json:"last_seen_at"`
        Access     string `json:"access"`
}

// getDopplerToken retrieves the Doppler token from environment
func getDopplerToken() string <span class="cov0" title="0">{
        // Check common environment variables
        envVars := []string{"DOPPLER_TOKEN", "DOPPLER_SERVICE_TOKEN"}

        for _, envVar := range envVars </span><span class="cov0" title="0">{
                if token := os.Getenv(envVar); token != "" </span><span class="cov0" title="0">{
                        return token
                }</span>
        }

        <span class="cov0" title="0">return ""</span>
}

// GenerateTokenName generates a standardized token name
func GenerateTokenName(prefix, environment string) string <span class="cov0" title="0">{
        return fmt.Sprintf("%s-%s-%s", prefix, environment, generateSlug())
}</span>

// generateSlug creates a simple slug
func generateSlug() string <span class="cov0" title="0">{
        // In a real implementation, this would generate a unique slug
        // For now, return a placeholder
        return "auto"
}</span>

// SetupCIEnvironment sets up environment for CI/CD
func SetupCIEnvironment(project, config, token string) error <span class="cov0" title="0">{
        envVars := map[string]string{
                "DOPPLER_TOKEN":       token,
                "DOPPLER_PROJECT":     project,
                "DOPPLER_CONFIG":      config,
                "DOPPLER_ENVIRONMENT": config,
        }

        for key, value := range envVars </span><span class="cov0" title="0">{
                if err := os.Setenv(key, value); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to set %s: %w", key, err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package e2e

import (
        "context"
        "os"
        "strings"
        "testing"
        "time"

        "obsidian-automation/cmd/mauritania-cli/internal/doppler"
)

// TestEnvironment represents a complete test environment setup
type TestEnvironment struct {
        DopplerManager *doppler.Manager
        OriginalEnv    map[string]string
        CleanupFuncs   []func()
}

// SetupTestEnvironment initializes the test environment with Doppler
func SetupTestEnvironment(t *testing.T, project, config string) *TestEnvironment <span class="cov1" title="2">{
        t.Helper()

        env := &amp;TestEnvironment{
                DopplerManager: doppler.NewManager(project, config),
                OriginalEnv:    make(map[string]string),
                CleanupFuncs:   []func(){},
        }

        // Save original environment
        for _, envVar := range os.Environ() </span><span class="cov7" title="128">{
                parts := strings.SplitN(envVar, "=", 2)
                if len(parts) == 2 </span><span class="cov7" title="128">{
                        env.OriginalEnv[parts[0]] = parts[1]
                }</span>
        }

        // Set up Doppler fallbacks for testing
        <span class="cov1" title="2">env.DopplerManager.WithFallbacks(map[string]string{
                "TEST_DATABASE_URL":  "sqlite://:memory:",
                "TEST_REDIS_ADDR":    "localhost:6379",
                "TEST_TIMEOUT":       "30",
                "TELEGRAM_BOT_TOKEN": "test_token",
                "WHATSAPP_API_KEY":   "test_key",
        })

        // Register cleanup
        t.Cleanup(func() </span><span class="cov1" title="2">{
                env.Cleanup(t)
        }</span>)

        <span class="cov1" title="2">return env</span>
}

// LoadTestSecrets loads test secrets from Doppler or fallbacks
func (env *TestEnvironment) LoadTestSecrets(ctx context.Context, t *testing.T) map[string]string <span class="cov1" title="1">{
        t.Helper()

        secrets, err := env.DopplerManager.LoadAllSecrets(ctx)
        if err != nil </span><span class="cov0" title="0">{
                t.Logf("Doppler not available, using fallbacks: %v", err)
                // Fallbacks are already set up in the manager
                secrets, err = env.DopplerManager.LoadAllSecrets(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        t.Fatalf("Failed to load test secrets: %v", err)
                }</span>
        }

        <span class="cov1" title="1">return secrets</span>
}

// SetTestEnvironment applies test environment variables
func (env *TestEnvironment) SetTestEnvironment(ctx context.Context, t *testing.T) <span class="cov1" title="1">{
        t.Helper()

        if err := env.DopplerManager.SetEnvironment(ctx); err != nil </span><span class="cov0" title="0">{
                t.Logf("Doppler environment setup failed, using fallbacks: %v", err)
                // Apply fallbacks manually
                fallbacks := map[string]string{
                        "TEST_DATABASE_URL":  "sqlite://:memory:",
                        "TEST_REDIS_ADDR":    "localhost:6379",
                        "TEST_TIMEOUT":       "30",
                        "TELEGRAM_BOT_TOKEN": "test_token",
                        "WHATSAPP_API_KEY":   "test_key",
                }

                for k, v := range fallbacks </span><span class="cov0" title="0">{
                        os.Setenv(k, v)
                }</span>
        }
}

// AddCleanup adds a cleanup function to be called at test end
func (env *TestEnvironment) AddCleanup(cleanup func()) <span class="cov0" title="0">{
        env.CleanupFuncs = append(env.CleanupFuncs, cleanup)
}</span>

// Cleanup restores the original environment and runs cleanup functions
func (env *TestEnvironment) Cleanup(t *testing.T) <span class="cov1" title="2">{
        // Run cleanup functions
        for _, cleanup := range env.CleanupFuncs </span><span class="cov0" title="0">{
                cleanup()
        }</span>

        // Clear test environment variables
        <span class="cov1" title="2">testPrefixes := []string{"TEST_", "DOPPLER_", "TELEGRAM_", "WHATSAPP_", "FACEBOOK_"}
        for _, envVar := range os.Environ() </span><span class="cov7" title="133">{
                parts := strings.SplitN(envVar, "=", 2)
                if len(parts) == 2 </span><span class="cov7" title="133">{
                        key := parts[0]
                        shouldRemove := false

                        for _, prefix := range testPrefixes </span><span class="cov10" title="642">{
                                if strings.HasPrefix(key, prefix) </span><span class="cov3" title="7">{
                                        shouldRemove = true
                                        break</span>
                                }
                        }

                        <span class="cov7" title="133">if shouldRemove </span><span class="cov3" title="7">{
                                os.Unsetenv(key)
                        }</span>
                }
        }

        // Restore original environment
        <span class="cov1" title="2">for key, value := range env.OriginalEnv </span><span class="cov7" title="128">{
                os.Setenv(key, value)
        }</span>

        // Clear Doppler cache
        <span class="cov1" title="2">env.DopplerManager.ClearCache()</span>
}

// WaitForService waits for a service to be available
func WaitForService(ctx context.Context, check func() error, timeout time.Duration) error <span class="cov1" title="1">{
        ctx, cancel := context.WithTimeout(ctx, timeout)
        defer cancel()

        ticker := time.NewTicker(100 * time.Millisecond)
        defer ticker.Stop()

        for </span><span class="cov1" title="1">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return ctx.Err()</span>
                case &lt;-ticker.C:<span class="cov1" title="1">
                        if err := check(); err == nil </span><span class="cov1" title="1">{
                                return nil
                        }</span>
                }
        }
}

// MockTransportServer creates a mock transport server for testing
func MockTransportServer(t *testing.T, transportType string) (string, func()) <span class="cov1" title="2">{
        t.Helper()

        // This would create mock servers for different transports
        // For now, return a placeholder
        switch transportType </span>{
        case "whatsapp":<span class="cov1" title="1">
                return "http://localhost:3001", func() </span>{<span class="cov0" title="0">}</span>
        case "telegram":<span class="cov1" title="1">
                return "http://localhost:3002", func() </span>{<span class="cov0" title="0">}</span>
        case "facebook":<span class="cov0" title="0">
                return "http://localhost:3003", func() </span>{<span class="cov0" title="0">}</span>
        default:<span class="cov0" title="0">
                t.Fatalf("Unsupported transport type: %s", transportType)
                return "", nil</span>
        }
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
